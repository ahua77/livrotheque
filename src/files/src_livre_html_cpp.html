<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>src_livre_html_cpp.html</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="SynEdit HTML exporter" />
<style type="text/css">
<!--
body { color: #000000; background-color: #FFFFFF; }
.cpp1-assembler { color: #0000FF; }
.cpp1-character { color: #000000; }
.cpp1-comment { color: #3399FF; font-style: italic; }
.cpp1-float { color: #800080; }
.cpp1-hexadecimal { color: #800080; }
.cpp1-identifier { color: #000000; }
.cpp1-illegalchar { color: #000000; }
.cpp1-number { color: #800080; }
.cpp1-octal { color: #800080; }
.cpp1-preprocessor { color: #008000; }
.cpp1-reservedword { color: #000000; font-weight: bold; }
.cpp1-space { background-color: #FFFFFF; color: #000000; }
.cpp1-string { color: #FF0000; }
.cpp1-symbol { color: #000000; }
-->
</style>
</head>
<body>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-comment">// Name:        livre_html.cpp
// Author:      PE EPAILLARD
// Created:     10/27/2004 12:22:10 AM
//
//Copyright PE Epaillard, 10/27/2004 
//
//Fougny@gmail.com
//
//Ce logiciel est un programme informatique servant &agrave; [rappeler les
//caract&eacute;ristiques techniques de votre logiciel]. 
//
//Ce logiciel est r&eacute;gi par la licence CeCILL soumise au droit fran&ccedil;ais et
//respectant les principes de diffusion des logiciels libres. Vous pouvez
//utiliser, modifier et/ou redistribuer ce programme sous les conditions
//de la licence CeCILL telle que diffus&eacute;e par le CEA, le CNRS et l'INRIA 
//sur le site &quot;http://www.cecill.info&quot;.
//
//En contrepartie de l'accessibilit&eacute; au code source et des droits de copie,
//de modification et de redistribution accord&eacute;s par cette licence, il n'est
//offert aux utilisateurs qu'une garantie limit&eacute;e.  Pour les m&ecirc;mes raisons,
//seule une responsabilit&eacute; restreinte p&egrave;se sur l'auteur du programme,  le
//titulaire des droits patrimoniaux et les conc&eacute;dants successifs.
//
//A cet &eacute;gard  l'attention de l'utilisateur est attir&eacute;e sur les risques
//associ&eacute;s au chargement,  &agrave; l'utilisation,  &agrave; la modification et/ou au
//d&eacute;veloppement et &agrave; la reproduction du logiciel par l'utilisateur &eacute;tant 
//donn&eacute; sa sp&eacute;cificit&eacute; de logiciel libre, qui peut le rendre complexe &agrave; 
//manipuler et qui le r&eacute;serve donc &agrave; des d&eacute;veloppeurs et des professionnels
//avertis poss&eacute;dant  des  connaissances  informatiques approfondies.  Les
//utilisateurs sont donc invit&eacute;s &agrave; charger  et  tester  l'ad&eacute;quation  du
//logiciel &agrave; leurs besoins dans des conditions permettant d'assurer la
//s&eacute;curit&eacute; de leurs syst&egrave;mes et ou de leurs donn&eacute;es et, plus g&eacute;n&eacute;ralement, 
//&agrave; l'utiliser et l'exploiter dans les m&ecirc;mes conditions de s&eacute;curit&eacute;. 
//
//Le fait que vous puissiez acc&eacute;der &agrave; cet en-t&ecirc;te signifie que vous avez 
//pris connaissance de la licence CeCILL, et que vous en avez accept&eacute; les
//termes.
//
//---------------------------------------------------------------------------
// Class automatically generated by Dev-C++ New Class wizard

</span><span class="cpp1-preprocessor">#include &quot;livre_html.h&quot; </span><span class="cpp1-comment">// class's header file
</span><span class="cpp1-preprocessor">#include &lt;wx/filename.h&gt;
#include &quot;secret_key.h&quot;

</span><span class="cpp1-reservedword">static</span><span class="cpp1-space"> wxString nouvelle_adresse;

</span><span class="cpp1-comment">// class constructor
</span><span class="cpp1-identifier">liste_caracteristiques::liste_caracteristiques()
  : wxList(wxKEY_STRING)
{
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-space">	DeleteContents(</span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">);
	test=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-comment">// class destructor
</span><span class="cpp1-identifier">liste_caracteristiques::~liste_caracteristiques()
{
    Clear();
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-symbol">}

</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> liste_caracteristiques::Init_parcours()
{
     </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node)
     {
         </span><span class="cpp1-comment">//Clear();
</span><span class="cpp1-space">     }
     node = GetFirst();
}

caracteristiques* liste_caracteristiques::Suivant()
{
    caracteristiques* caract;
    caract = </span><span class="cpp1-reservedword">new</span><span class="cpp1-space"> caracteristiques();
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node)
    {
        caract = (caracteristiques*) node-&gt;GetData();
        node = node-&gt;GetNext();
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
        caract = NULL;
    }

    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> caract;
}

</span><span class="cpp1-comment">//
//caracteristiques* liste_caracteristiques::Get_caract(wxString strKey)
//{
//    caracteristiques* caract;
//    caract = new caracteristiques();
//    caract = (caracteristiques*) Get(strKey);
//    return caract;
//}

</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> liste_caracteristiques::Effacer()
{
     Clear();
     test=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> liste_caracteristiques::Ajouter(caracteristiques* caract)
{
    Append(wxString::Format(</span><span class="cpp1-string">&quot;%d&quot;</span><span class="cpp1-symbol">,test), caract);
    </span><span class="cpp1-comment">//Append((wxObject*)caract);
</span><span class="cpp1-space">    test++;
}

</span><span class="cpp1-comment">// class constructor
</span><span class="cpp1-identifier">caracteristiques::caracteristiques()
{
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-symbol">}

</span><span class="cpp1-comment">// class destructor
</span><span class="cpp1-identifier">caracteristiques::~caracteristiques()
{
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-symbol">}

wxString caracteristiques::Affiche()
{
    wxString retour;
    retour = Titre + </span><span class="cpp1-string">&quot; - &quot;</span><span class="cpp1-space"> + Auteur + </span><span class="cpp1-string">&quot; - &quot;</span><span class="cpp1-space"> + Editeur + </span><span class="cpp1-string">&quot; - &quot;</span><span class="cpp1-space"> + Genre + </span><span class="cpp1-string">&quot; ISBN=&quot;</span><span class="cpp1-space"> + Isbn;
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> retour;
}

</span><span class="cpp1-comment">// class constructor
</span><span class="cpp1-identifier">LIVRE_HTML::LIVRE_HTML()
{
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-symbol">}
</span><span class="cpp1-comment">// class destructor
</span><span class="cpp1-identifier">LIVRE_HTML::~LIVRE_HTML()
{
	</span><span class="cpp1-comment">// insert your code here
</span><span class="cpp1-symbol">}

</span><span class="cpp1-comment">// returns the value of num_isbn
</span><span class="cpp1-identifier">wxString LIVRE_HTML::Getnum_isbn()
{
	</span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> num_isbn;
}

</span><span class="cpp1-comment">// sets the value of num_isbn
</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> LIVRE_HTML::Setnum_isbn(wxString x)
{
	num_isbn = x;
}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::recupData(wxString url,wxString nom_fichier)
{
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::recupData() */
</span><span class="cpp1-space">	</span><span class="cpp1-comment">/* TODO (#1#): Implement testFrm::recupereHTML() */
</span><span class="cpp1-space">  CURL *curl_handle;
  wxString headerfilename = gettempdir() + wxFileName::GetPathSeparators() + wxT(</span><span class="cpp1-string">&quot;head.html&quot;</span><span class="cpp1-symbol">);
  wxFile* headerfile;
  wxFile* bodyfile;
  wxString tempo;
  </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> nouv_recherche=</span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
  
  headerfile = </span><span class="cpp1-reservedword">new</span><span class="cpp1-space"> wxFile();
  bodyfile = </span><span class="cpp1-reservedword">new</span><span class="cpp1-space"> wxFile();
  nouvelle_adresse=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;

  </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> posit_id=url.Find(</span><span class="cpp1-string">&quot;?id=&quot;</span><span class="cpp1-symbol">);
  </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (posit_id != wxNOT_FOUND &amp;&amp; posit_id&gt;</span><span class="cpp1-number">1</span><span class="cpp1-symbol">) {
    url=url.Left(posit_id);
  }
  
  curl_global_init(CURL_GLOBAL_ALL);
  </span><span class="cpp1-comment">/* init the curl session */
</span><span class="cpp1-space">  curl_handle = curl_easy_init();

  </span><span class="cpp1-comment">//  wxMessageBox(nom_fichier+ &quot;\n&quot; + url,&quot;traitement de&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">  </span><span class="cpp1-comment">/* set URL to get */
</span><span class="cpp1-space">  curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());

  </span><span class="cpp1-comment">/* no progress meter please */
</span><span class="cpp1-space">  curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, </span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
  curl_easy_setopt(curl_handle, CURLOPT_CONNECTTIMEOUT, </span><span class="cpp1-number">60</span><span class="cpp1-symbol">);
  
  curl_easy_setopt(curl_handle,CURLOPT_VERBOSE,</span><span class="cpp1-number">0</span><span class="cpp1-symbol">); 
  </span><span class="cpp1-comment">/* shut up completely */
</span><span class="cpp1-space">  
  </span><span class="cpp1-comment">/* send all data to this function  */
</span><span class="cpp1-space">  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, &amp;LIVRE_HTML::write_d);
  </span><span class="cpp1-comment">/* open the files */
</span><span class="cpp1-space">  </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (headerfile-&gt;Create(headerfilename.GetData(),</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">,wxS_DEFAULT) == </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">) {
    curl_easy_cleanup(curl_handle);
    wxMessageBox(</span><span class="cpp1-string">&quot;Probleme ouverture fichier &quot;</span><span class="cpp1-symbol">+headerfilename,</span><span class="cpp1-string">&quot;fichier&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
  }
  
  </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (bodyfile-&gt;Create(nom_fichier.GetData(),</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">,wxS_DEFAULT) == </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">) {
    curl_easy_cleanup(curl_handle); 
    wxMessageBox(wxT(</span><span class="cpp1-string">&quot;Probleme ouverture fichier &quot;</span><span class="cpp1-symbol">) + nom_fichier,</span><span class="cpp1-string">&quot;fichier&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
  }
         </span><span class="cpp1-comment">//wxMessageBox(nom_fichier+&quot;\n&quot;+url,&quot;Titre&quot;, wxOK | wxICON_EXCLAMATION);

</span><span class="cpp1-space">  </span><span class="cpp1-comment">/* we want the headers to this file handle */
</span><span class="cpp1-space">  curl_easy_setopt(curl_handle,   CURLOPT_WRITEDATA ,bodyfile);
  curl_easy_setopt(curl_handle,   CURLOPT_WRITEHEADER ,headerfile);
  
  </span><span class="cpp1-comment">/*
   * Notice here that if you want the actual data sent anywhere else but
   * stdout, you should consider using the CURLOPT_WRITEDATA option.  */
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (prox_utilise == </span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">) {
   </span><span class="cpp1-comment">// wxMessageBox(prox_adresse ,&quot;PROXY!!!&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        curl_easy_setopt(curl_handle,   CURLOPT_PROXYTYPE,CURLPROXY_HTTP);
        curl_easy_setopt(curl_handle,   CURLOPT_PROXY ,prox_adresse.GetData());
        curl_easy_setopt(curl_handle,   CURLOPT_PROXYPORT ,prox_port);
        tempo=prox_user+</span><span class="cpp1-string">&quot;:&quot;</span><span class="cpp1-symbol">+prox_pass;
        curl_easy_setopt(curl_handle,   CURLOPT_PROXYUSERPWD,tempo.GetData());
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
   </span><span class="cpp1-comment">// wxMessageBox( url,&quot; PAS PROXY!!!&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        curl_easy_setopt(curl_handle,   CURLOPT_PROXY ,</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">);
    }
   </span><span class="cpp1-comment">// wxMessageBox(&quot;a4\n&quot; + url,&quot;traitement de&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">  </span><span class="cpp1-comment">/* get it! */
</span><span class="cpp1-space">  curl_easy_perform(curl_handle);
  </span><span class="cpp1-comment">//  wxMessageBox(&quot;a5\n&quot; + url,&quot;traitement de&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">  
  </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (bodyfile-&gt;Length()==</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; nouvelle_adresse.Len() &gt; </span><span class="cpp1-number">0</span><span class="cpp1-symbol">) {
      </span><span class="cpp1-comment">//   wxMessageBox(nom_fichier+&quot;\n&quot;+url,nouvelle_adresse, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">         nouv_recherche=</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">;
    }
  
  </span><span class="cpp1-comment">/* close the header file */
</span><span class="cpp1-space">  bodyfile-&gt;Close();
  headerfile-&gt;Close();

  </span><span class="cpp1-comment">/* cleanup curl stuff */
</span><span class="cpp1-space">  curl_easy_cleanup(curl_handle);
  </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (nouv_recherche == </span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">) {
        recupData(nouvelle_adresse, nom_fichier);
  }
         </span><span class="cpp1-comment">//wxMessageBox(&quot;fin&quot;,nouvelle_adresse, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">  </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-identifier">size_t LIVRE_HTML::write_d(</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> *ptr,size_t size, size_t nmemb, </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> *stream)
{
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::write_d() */
</span><span class="cpp1-space">   </span><span class="cpp1-comment">//int written = fwrite(ptr, size, nmemb, (FILE *)stream);
</span><span class="cpp1-space">    wxString ret;
    ret.Printf(</span><span class="cpp1-string">&quot;taille1=%d,taille2=%d,%s\n&quot;</span><span class="cpp1-symbol">,size,nmemb,(</span><span class="cpp1-reservedword">char</span><span class="cpp1-symbol">*)ptr);
       </span><span class="cpp1-comment">//wxMessageBox(ret,&quot;test&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    wxString donnee((</span><span class="cpp1-reservedword">char</span><span class="cpp1-symbol">*)ptr);
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> written = ((wxFile*)stream)-&gt;Write(ptr,nmemb);
    </span><span class="cpp1-comment">//wxMessageBox(donnee,&quot;test&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-symbol">(donnee.StartsWith(</span><span class="cpp1-string">&quot;Location:&quot;</span><span class="cpp1-symbol">)) {
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (donnee.Mid(</span><span class="cpp1-number">10</span><span class="cpp1-symbol">).StartsWith(</span><span class="cpp1-string">&quot;http://&quot;</span><span class="cpp1-symbol">)) {
            nouvelle_adresse=donnee.Mid(</span><span class="cpp1-number">10</span><span class="cpp1-symbol">);
        } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
            nouvelle_adresse=wxT(</span><span class="cpp1-string">&quot;http://www.alapage.com&quot;</span><span class="cpp1-symbol">)+donnee.Mid(</span><span class="cpp1-number">10</span><span class="cpp1-symbol">);
        </span><span class="cpp1-comment">//wxMessageBox(nouvelle_adresse,&quot;POUET&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        }
    }
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> written;
}
 
wxString LIVRE_HTML::recup_donnee(wxString donnee, wxString debut, wxString fin, </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> type_recup) {
    wxString resultat;
    size_t debut_d, fin_d;
    </span><span class="cpp1-comment">//int fin_d;
</span><span class="cpp1-space">    
    debut_d=donnee.Find(debut);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (debut_d == wxNOT_FOUND || debut_d&lt;</span><span class="cpp1-number">20</span><span class="cpp1-symbol">) {
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    } 
    debut_d+=debut.Len();
    resultat=donnee.Mid(debut_d);
    </span><span class="cpp1-comment">//wxMessageBox(wxString::Format(&quot;%d&quot;, debut_d) ,debut, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    fin_d=resultat.Find(fin); 
    </span><span class="cpp1-comment">//wxMessageBox(wxString::Format(&quot;%d&quot;, fin_d) ,fin, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    resultat=resultat.Left(fin_d);
     </span><span class="cpp1-comment">// changement des &lt;BR&gt; par \n
</span><span class="cpp1-space">   resultat.Replace(</span><span class="cpp1-string">&quot;&lt;BR&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;\n&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    resultat.Replace(</span><span class="cpp1-string">&quot;&lt;br&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;\n&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    resultat.Replace(</span><span class="cpp1-string">&quot;&lt;br /&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;\n&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    resultat.Replace(</span><span class="cpp1-string">&quot;&lt;BR /&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;\n&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    </span><span class="cpp1-comment">// suppression des blancs de d&eacute;but et de fin
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> i=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
    </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> ((resultat[i]==' ' || resultat[i]=='\t' || resultat[i]=='\n') &amp;&amp; i&lt;resultat.Len()) {
        i++;
    }
    resultat=resultat.Mid(i);
    i=resultat.Len();
    </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> ((resultat[i]==' ' || resultat[i]=='\t') &amp;&amp; i&gt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">) {
        i--;
    }
    resultat=resultat.Left(i);
    
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recup == </span><span class="cpp1-number">0</span><span class="cpp1-symbol">) {
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (resultat.StartsWith(</span><span class="cpp1-string">&quot;&lt;&quot;</span><span class="cpp1-symbol">)) {
            resultat=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
        }
    }
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> resultat;
}
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::traiter_isbn_amazon(wxString ws_isbn,wxString img_recto,wxString img_verso,caracteristiques&amp; caract, </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> type_recherche) {
    </span><span class="cpp1-comment">/*
    la demande 
    http://ecs.amazonaws.fr/onca/xml?Service=AWSECommerceService&amp;AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;Operation=ItemLookup&amp;SearchIndex=Books&amp;ResponseGroup=Medium,EditorialReview,Reviews,Subjects&amp;IdType=ISBN&amp;Version=2007-07-16&amp;ItemId=9782070426829
    
     ce qu'il faut signer 
    GET
ecs.amazonaws.fr
/onca/xml
AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-03T15%3A33%3A35.000Z&amp;Version=2007-07-16

aka :
    GET\nwebservices.amazon.com\n/onca/xml\nAWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-03T15%3A33%3A35.000Z&amp;Version=2007-07-16

    doit donner 
    http://ecs.amazonaws.fr/onca/xml?AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-03T15%3A33%3A35.000Z&amp;Version=2007-07-16&amp;Signature=
    M7vJrb82hcfMvzT2o8QcRG2MILdN6YQo4CsHr3OKBgU%3D
*/</span><span class="cpp1-space">    
    wxString test_encode=</span><span class="cpp1-string">&quot;GET\necs.amazonaws.fr\n/onca/xml\nAWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-04T15%3A20%3A43.000Z&amp;Version=2007-07-16&quot;</span><span class="cpp1-symbol">;
</span><span class="cpp1-comment">//                             GET\necs.amazonaws.fr\n/onca/xml\nAWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-04T13%3A22%3A16.000Z&amp;Version=2007-07-16
</span><span class="cpp1-space">    </span><span class="cpp1-comment">//strcpy(uencode,&quot;GET\nwebservices.amazon.com\n/onca/xml\nAWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=9782070426829&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=2009-09-04T13%3A22%3A16.000Z&amp;Version=2007-07-16&quot;);
</span><span class="cpp1-space">    
    num_isbn = ws_isbn;
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> retour;
    wxString page_xml;
    wxFFile fichier;
    wxString fichier_xml=gettempdir() + wxFileName::GetPathSeparators() + ws_isbn+wxT(</span><span class="cpp1-string">&quot;.xml&quot;</span><span class="cpp1-symbol">);
    wxXmlDocument amazon;
    wxXmlNode *node_cible;
    
    wxDateTime now = wxDateTime::Now();
    wxDateTime now_GMT = now.ToGMT();
    
    </span><span class="cpp1-comment">//wxString parametres=&quot;AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=&quot;+ws_isbn+&quot;&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=&quot;+now.FormatISODate()+&quot;T&quot;+now.FormatISOTime()+&quot;.000Z&amp;Version=2007-07-16&quot;;
</span><span class="cpp1-space">    wxString parametres=</span><span class="cpp1-string">&quot;AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;IdType=ISBN&amp;ItemId=&quot;</span><span class="cpp1-symbol">+ws_isbn+</span><span class="cpp1-string">&quot;&amp;Operation=ItemLookup&amp;ResponseGroup=Medium%2CEditorialReview%2CReviews%2CSubjects&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=&quot;</span><span class="cpp1-symbol">+now_GMT.FormatISODate()+</span><span class="cpp1-string">&quot;T&quot;</span><span class="cpp1-symbol">+now_GMT.FormatISOTime()+</span><span class="cpp1-string">&quot;.000Z&amp;Version=2007-07-16&quot;</span><span class="cpp1-symbol">;
    </span><span class="cpp1-comment">//wxMessageBox(parametres,&quot;parametres&quot;, wxOK | wxICON_EXCLAMATION);

</span><span class="cpp1-space">    wxString adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.fr&quot;</span><span class="cpp1-symbol">;
    
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche == </span><span class="cpp1-number">2</span><span class="cpp1-symbol">) {
    	adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.com&quot;</span><span class="cpp1-symbol">;
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche == </span><span class="cpp1-number">3</span><span class="cpp1-symbol">) {
    	adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.co.uk&quot;</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-comment">//url_amazon_com=url_amazon_com + ws_isbn, fichier_xml;
</span><span class="cpp1-space">    wxString url_amazon_com=sk::creer_adresse(adresse,parametres);
    
    </span><span class="cpp1-comment">//wxGetTextFromUser(&quot;test&quot;,&quot;test&quot;,url_amazon_com);

</span><span class="cpp1-space">    </span><span class="cpp1-comment">//wxMessageBox(url_amazon_com,&quot;toto&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">//retour=recupData(url_amazon_com + ws_isbn, fichier_xml);
</span><span class="cpp1-space">    retour=recupData(url_amazon_com , fichier_xml);

    </span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> ret=fichier.Open(fichier_xml);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (ret==</span><span class="cpp1-reservedword">false</span><span class="cpp1-space"> || retour&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       wxMessageBox(</span><span class="cpp1-string">&quot;probleme ouverture fichier temporaire&quot;</span><span class="cpp1-symbol">,fichier_xml, wxOK | wxICON_EXCLAMATION);
       </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }</span><span class="cpp1-comment">/* else {
       fichier.ReadAll(&amp;page_xml);
       wxMessageBox(page_xml,fichier_xml, wxOK | wxICON_EXCLAMATION);
    }*/
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> test=amazon.Load(fichier_xml,wxT(</span><span class="cpp1-string">&quot;ISO-8859-1&quot;</span><span class="cpp1-symbol">));
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (test == </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">) {
        wxMessageBox(</span><span class="cpp1-string">&quot;probleme de lecture du fichier XML&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;r&eacute;cup&eacute;ration&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-comment">//wxMessageBox(&quot;OK&quot;,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">// on r&eacute;cup&egrave;re le node papa (le root quoi)
</span><span class="cpp1-space">    wxXmlNode *papa_root=amazon.GetRoot();
    </span><span class="cpp1-comment">//wxMessageBox(papa_root-&gt;GetName(),&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">// on r&eacute;cup&egrave;re le premier fils
</span><span class="cpp1-space">    </span><span class="cpp1-comment">//wxXmlNode *petit_node=papa_root-&gt;GetChildren();
</span><span class="cpp1-space">	
    </span><span class="cpp1-comment">// On regarde si il y a eu une erreur durant la recherche
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Error&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        wxString message=</span><span class="cpp1-string">&quot;probleme lors de la lecture de l'isbn : &quot;</span><span class="cpp1-symbol">+ ws_isbn;
        node_cible=cherche_node(</span><span class="cpp1-string">&quot;Message&quot;</span><span class="cpp1-symbol">,node_cible);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
            message=message+</span><span class="cpp1-string">&quot;\n\nMessage d'Amazon : &quot;</span><span class="cpp1-symbol">+node_cible-&gt;GetNodeContent();
            wxMessageBox(message,</span><span class="cpp1-string">&quot;Erreur r&eacute;cup&eacute;ration&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
        }
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-comment">// si y a pas d'erreur (c'est lesieur) on recherce les donn&eacute;es
</span><span class="cpp1-space">    </span><span class="cpp1-comment">// recherche de l'auteur
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Title&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Titre=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Author&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Auteur=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Publisher&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Editeur=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Subject&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Genre=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;PublicationDate&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Date_parution=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
        wxString date_tempo=node_cible-&gt;GetNodeContent();
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (date_tempo.Len() == </span><span class="cpp1-number">10</span><span class="cpp1-symbol">) {
            caract.Date_parution=caract.Date_parution+date_tempo.Mid(</span><span class="cpp1-number">8</span><span class="cpp1-symbol">)+</span><span class="cpp1-string">&quot;/&quot;</span><span class="cpp1-symbol">;
            date_tempo=date_tempo.Left(</span><span class="cpp1-number">8</span><span class="cpp1-symbol">);
        }
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (date_tempo.Len() == </span><span class="cpp1-number">8</span><span class="cpp1-symbol">) 
            date_tempo=date_tempo.Left(</span><span class="cpp1-number">7</span><span class="cpp1-symbol">);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Date_parution.Len()==</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
            caract.Date_parution=</span><span class="cpp1-string">&quot;01/&quot;</span><span class="cpp1-symbol">;
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (date_tempo.Len() == </span><span class="cpp1-number">7</span><span class="cpp1-symbol">) {
            caract.Date_parution=caract.Date_parution+date_tempo.Mid(</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)+</span><span class="cpp1-string">&quot;/&quot;</span><span class="cpp1-symbol">;
            date_tempo=date_tempo.Left(</span><span class="cpp1-number">5</span><span class="cpp1-symbol">);
        }
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (date_tempo.Len() == </span><span class="cpp1-number">5</span><span class="cpp1-symbol">)
            date_tempo=date_tempo.Left(</span><span class="cpp1-number">4</span><span class="cpp1-symbol">);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Date_parution.Len()==</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)
            caract.Date_parution=caract.Date_parution+</span><span class="cpp1-string">&quot;01/&quot;</span><span class="cpp1-symbol">;
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (date_tempo.Len() == </span><span class="cpp1-number">4</span><span class="cpp1-symbol">) {
            caract.Date_parution=caract.Date_parution+date_tempo;
        }
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Date_parution.Len()&lt;</span><span class="cpp1-number">6</span><span class="cpp1-symbol">)
            caract.Date_parution=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Creator&quot;</span><span class="cpp1-symbol">,papa_root,</span><span class="cpp1-string">&quot;Traduction&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Traducteur=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Binding&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Presentation=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;NumberOfPages&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Nb_pages=node_cible-&gt;GetNodeContent();
    }
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Amount&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        </span><span class="cpp1-reservedword">double</span><span class="cpp1-space"> val=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        caract.Prix=node_cible-&gt;GetNodeContent();
        caract.Prix.ToDouble(&amp;val);
        val=val/</span><span class="cpp1-number">100</span><span class="cpp1-symbol">;
        caract.Prix.Printf(</span><span class="cpp1-string">&quot;%.2f&quot;</span><span class="cpp1-symbol">,val);
    }
    caract.Url=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;DetailPageURL&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        caract.Url=node_cible-&gt;GetNodeContent();
    }

    </span><span class="cpp1-comment">// r&eacute;cup&eacute;ration des commentaire editoriaux
</span><span class="cpp1-space">    caract.Commentaires=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    node_cible=cherche_node(</span><span class="cpp1-string">&quot;EditorialReview&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        node_cible=cherche_node(</span><span class="cpp1-string">&quot;Content&quot;</span><span class="cpp1-symbol">,node_cible);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL)
            caract.Commentaires=node_cible-&gt;GetNodeContent();
    }
        </span><span class="cpp1-comment">//wxMessageBox(caract.Commentaires,&quot;EditorialReview&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    
    </span><span class="cpp1-comment">//wxMessageBox(caract.Url,&quot;url 1&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">// si il y a rien on essaye d'ouvrir la page HTML et on cherche la 4eme de couverture
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Commentaires.Len()&lt;</span><span class="cpp1-number">10</span><span class="cpp1-space"> &amp;&amp; caract.Url.Len() &gt; </span><span class="cpp1-number">10</span><span class="cpp1-symbol">) {
        wxString fichier_html=gettempdir() + wxFileName::GetPathSeparators() + ws_isbn+wxT(</span><span class="cpp1-string">&quot;.html&quot;</span><span class="cpp1-symbol">);
        wxFFile html_file;

        </span><span class="cpp1-comment">//wxMessageBox(caract.Url,&quot;url 2&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        retour=recupData(caract.Url , fichier_html);
        html_file.Open(fichier_html);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (html_file.IsOpened()) {
            wxString page_html;
            html_file.ReadAll(&amp;page_html);
            caract.Commentaires=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Quatri&amp;#232;me de couverture&lt;/b&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/div&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
            </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Commentaires.Len()&lt;</span><span class="cpp1-number">10</span><span class="cpp1-symbol">) {
                caract.Commentaires=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Pr&amp;#233;sentation de l'&amp;#233;diteur&lt;/b&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/div&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
            }
            </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Commentaires.Len()&lt;</span><span class="cpp1-number">10</span><span class="cpp1-symbol">) {
                caract.Commentaires=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Pr&amp;#233;sentation de l&amp;#146;&amp;#233;diteur&lt;/b&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/div&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
            }
            
            </span><span class="cpp1-comment">//wxMessageBox(caract.Commentaires,&quot;comm&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
            </span><span class="cpp1-comment">//wxMessageBox(&quot;POUET&quot;,&quot;url&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        }
        </span><span class="cpp1-comment">//Descriptions du produit   //&lt;div class=&quot;content&quot;&gt;   // &lt;/div&gt;
</span><span class="cpp1-space">    }    
    </span><span class="cpp1-comment">// si il y a toujours rien on prend le premier commentaire d'un utilisateur
</span><span class="cpp1-space">  </span><span class="cpp1-comment">/*  if (caract.Commentaires==&quot;&quot;) {
        node_cible=cherche_node(&quot;Review&quot;,papa_root);
        if (node_cible != NULL) {
            node_cible=cherche_node(&quot;Content&quot;,node_cible);
            if (node_cible != NULL) 
                caract.Commentaires=node_cible-&gt;GetNodeContent();
        }
    }*/
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;LargeImage&quot;</span><span class="cpp1-symbol">,papa_root);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible == NULL) {
        node_cible=cherche_node(</span><span class="cpp1-string">&quot;MediumImage&quot;</span><span class="cpp1-symbol">,papa_root);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible == NULL) {
            node_cible=cherche_node(</span><span class="cpp1-string">&quot;SmallImage&quot;</span><span class="cpp1-symbol">,papa_root);
        }
    }
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        node_cible=cherche_node(</span><span class="cpp1-string">&quot;URL&quot;</span><span class="cpp1-symbol">,node_cible);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
            caract.Url_img_r=node_cible-&gt;GetNodeContent();
	       retour=recupData(caract.Url_img_r ,img_recto);
        }
    }
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::traiter_isbn(wxString ws_isbn,wxString img_recto,wxString img_verso,caracteristiques&amp; caract, </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> type_recherche)
{
    
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche != </span><span class="cpp1-number">1</span><span class="cpp1-symbol">) {
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> traiter_isbn_amazon(ws_isbn,img_recto,img_verso, caract, type_recherche);
    }
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::traiter_isbn() */
</span><span class="cpp1-space">	</span><span class="cpp1-comment">//&quot;http://www.alapage.com/resize.php?&amp;type=1&amp;r=0&amp;s=0&amp;ref=9782226179647&amp;m=r&quot;
</span><span class="cpp1-space">	</span><span class="cpp1-comment">//wxString url_alapage_img=wxT(&quot;http://www.alapage.com/get_img.php?cgi=livre_l&amp;ref=l_isbn&amp;num_ref=&quot;);
</span><span class="cpp1-space">	wxString url_alapage_img=wxT(</span><span class="cpp1-string">&quot;http://www.alapage.com/resize.php?&amp;type=1&amp;r=0&amp;s=0&amp;ref=&quot;</span><span class="cpp1-symbol">);
	</span><span class="cpp1-comment">//wxString url_alapage_com=wxT(&quot;http://www.alapage.com/mx/?tp=F&amp;type=1&amp;l_isbn=&quot;);
</span><span class="cpp1-space">	wxString url_alapage_com=wxT(</span><span class="cpp1-string">&quot;http://www.alapage.com/-/Fiche/Livres/&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> retour,retour2,retour3;
	wxFFile file;
	wxString page_html,page_tmp;
	wxString fichier_com=gettempdir() + wxFileName::GetPathSeparators() + wxT(</span><span class="cpp1-string">&quot;com.html&quot;</span><span class="cpp1-symbol">);
		
	num_isbn = ws_isbn;
	retour=recupData(url_alapage_img + ws_isbn +</span><span class="cpp1-string">&quot;&amp;m=r&quot;</span><span class="cpp1-symbol">,img_recto);
	retour2=recupData(url_alapage_img + ws_isbn +</span><span class="cpp1-string">&quot;&amp;m=v&quot;</span><span class="cpp1-symbol">,img_verso);
	</span><span class="cpp1-comment">//retour3=recupData(url_alapage_com + ws_isbn,&quot;com.html&quot;);
</span><span class="cpp1-space">	retour3=recupData(url_alapage_com + ws_isbn + </span><span class="cpp1-string">&quot;/&quot;</span><span class="cpp1-symbol">,fichier_com);
	caract.Url=url_alapage_com + ws_isbn + </span><span class="cpp1-string">&quot;/&quot;</span><span class="cpp1-symbol">;
    
    </span><span class="cpp1-comment">//wxMessageBox(&quot;coco!!!&quot;,fichier_com, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">	
	</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> ret=file.Open(fichier_com);
	</span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (ret==</span><span class="cpp1-reservedword">false</span><span class="cpp1-space"> || retour3&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
	{
       wxMessageBox(</span><span class="cpp1-string">&quot;probleme ouverture fichier temporaire&quot;</span><span class="cpp1-symbol">,fichier_com, wxOK | wxICON_EXCLAMATION);
       </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
       file.ReadAll(&amp;page_html);
       page_tmp=page_html;
    }
    file.Close();
    </span><span class="cpp1-comment">//wxMessageBox(&quot;coco2!!!&quot;,fichier_com, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> test_page=page_html.Find(</span><span class="cpp1-string">&quot;Le produit demand&eacute; n'est plus disponible&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (test_page != -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">) {
        wxMessageBox(</span><span class="cpp1-string">&quot;Ce livre n'est plus disponible sur alapage \n la r&eacute;cup&eacute;ration des donn&eacute;es ne peut &ecirc;tre faite&quot;</span><span class="cpp1-space"> ,</span><span class="cpp1-string">&quot;Probleme&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-comment">//wxMessageBox(wxString::Format(&quot;%d&quot;, test_page) ,&quot;test_page&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    
    caract.Titre=recup_donnee(page_html, </span><span class="cpp1-string">&quot;&lt;h2 class=\&quot;big_black_title\&quot;&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/h2&gt;&quot;</span><span class="cpp1-symbol">);
    caract.Isbn=recup_donnee(page_html, </span><span class="cpp1-string">&quot;ISBN : &lt;strong&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/strong&gt;&lt;/li&gt;&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-comment">//caract.Traducteur=recup_donnee(page_html, 
</span><span class="cpp1-space">    caract.Presentation=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Pr&eacute;sentation : &quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&lt;/li&gt;&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-comment">//caract.Langue=recup_donnee(page_html, 
</span><span class="cpp1-space">    caract.Date_parution=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Date de parution : &lt;strong&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&lt;/strong&gt;&lt;/li&gt;&quot;</span><span class="cpp1-symbol">);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (caract.Date_parution.Len()&lt;</span><span class="cpp1-number">10</span><span class="cpp1-symbol">) {
        caract.Date_parution=</span><span class="cpp1-string">&quot;01/&quot;</span><span class="cpp1-symbol">+caract.Date_parution;
    }
    caract.Genre=recup_donnee(page_html, </span><span class="cpp1-string">&quot;, Genre &quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;\&quot; &quot;</span><span class="cpp1-symbol">);
    caract.Collection=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Collection : &lt;strong&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&lt;/strong&gt;&lt;/li&gt;&quot;</span><span class="cpp1-symbol">);
    caract.Editeur=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Editeur : &lt;strong&gt;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&lt;/strong&gt;&lt;/li&gt;&quot;</span><span class="cpp1-symbol">);
    caract.Commentaires=recup_donnee(page_html, </span><span class="cpp1-string">&quot;&lt;div class=\&quot;blocWithMargin\&quot;&gt;\n&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&amp;nbsp;&quot;</span><span class="cpp1-symbol">);
    caract.Auteur=recup_donnee(page_html, </span><span class="cpp1-string">&quot;Auteur : &lt;strong&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/strong&gt;&quot;</span><span class="cpp1-symbol">);
    caract.Prix=recup_donnee(page_html, </span><span class="cpp1-string">&quot;&lt;/div&gt;&lt;/li&gt;&lt;li class=\&quot;margintophalf\&quot;&gt;&lt;strong class='bigbold section_colortxt'&gt;&lt;span class='linethrough'&gt;&quot;</span><span class="cpp1-symbol">, </span><span class="cpp1-string">&quot;&lt;/span&gt;&quot;</span><span class="cpp1-symbol">);
</span><span class="cpp1-comment">/*    if (chercher_TD(page_html,wxT(&quot;ISBN :&quot;),caract.Editeur,0,true)!=0)
    {
       wxMessageBox(&quot;Impossible de r&eacute;cuperer les caracteristiques&quot;,&quot;Caracteristiques&quot;, wxOK | wxICON_EXCLAMATION);
    } else {
    wxMessageBox(&quot;coco3!!!&quot;,fichier_com, wxOK | wxICON_EXCLAMATION);
       trancher(caract.Ean,caract.Editeur,&quot;- EAN :&quot;);
    wxMessageBox(&quot;coco4!!!&quot;,caract.Ean, wxOK | wxICON_EXCLAMATION);
       trancher(caract.Isbn,caract.Editeur,&quot;ISBN :&quot;);
       trancher(caract.Presentation,caract.Editeur,&quot;Pr&eacute;sentation :&quot;);
       trancher(caract.Traducteur,caract.Editeur,&quot;traduit par&quot;);
       trancher(caract.Langue,caract.Editeur,&quot;Texte d'origine&quot;);
       trancher(caract.Date_parution,caract.Editeur,&quot;Date de Parution :&quot;);
       trancher(caract.Genre,caract.Editeur,&quot;Genre :&quot;);
       trancher(caract.Collection,caract.Editeur,&quot;Collection :&quot;);
       trancher(caract.Editeur,caract.Editeur,&quot;Editeur :&quot;);
    }
    if (chercher_TD(page_html,wxT(&quot;&lt;span style=\&quot;color:#414B55;\&quot;&gt;&quot;),caract.Titre,0,true)!=0)
    {
       wxMessageBox(&quot;Impossible de r&eacute;cuperer le titre&quot;,&quot;Titre&quot;, wxOK | wxICON_EXCLAMATION);
    } else {
       trancher(caract.Auteur,caract.Titre,&quot;de :&quot;);
    }
    
    if (chercher_TD(page_html,wxT(&quot;Commentaires&lt;/TD&gt;&quot;),caract.Commentaires,3,true)!=0)
    {
       if (chercher_TD(page_html,wxT(&quot;Message de l'auteur&lt;/TD&gt;&quot;),caract.Commentaires,3,true)!=0)
       {
           if (chercher_TD(page_html,wxT(&quot;Revue de presse&lt;/TD&gt;&quot;),caract.Commentaires,3,true)!=0)
           {
               wxMessageBox(&quot;Impossible de r&eacute;cuperer le commentaire&quot;,&quot;Commentaires&quot;, wxOK | wxICON_EXCLAMATION);
           } else {
               //wxMessageBox(&quot;Revue de presse &agrave; la con ...&quot;,&quot;Commentaires&quot;, wxOK | wxICON_EXCLAMATION);
           }
       } else {
           ///wxMessageBox(&quot;Juste pour PE ...&quot;,&quot;Commentaires&quot;, wxOK | wxICON_EXCLAMATION);
       }
       
    }
    
    if (chercher_TD(page_html,wxT(&quot;Prix &eacute;diteur :&quot;),caract.Prix,1,true)!=0)
    {
       if (chercher_TD(page_html,wxT(&quot;Prix &amp;eacute;diteur :&quot;),caract.Prix,1,true)!=0)
       {
          wxMessageBox(&quot;Impossible de r&eacute;cuperer le prix&quot;,&quot;Prix&quot;, wxOK | wxICON_EXCLAMATION);
       } else {
          caract.Prix=(caract.Prix.Remove(caract.Prix.Find(&quot;Euros&quot;))).Trim(true) + &quot; Euros&quot;;
       }
    } else {
       caract.Prix=(caract.Prix.Remove(caract.Prix.Find(&quot;Euros&quot;))).Trim(true) + &quot; Euros&quot;;
    }
    */
</span><span class="cpp1-space">	</span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::chercher_TD(wxString texte,wxString texte_a_chercher,wxString&amp; texte_retour,</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> decalage,</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> suppr_balise)
{
    wxString texte_debut;
    wxString texte_fin;
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> debut,fin=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
    
    debut=texte.First(texte_a_chercher);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (debut == -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (decalage&gt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (decalage&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length())
       {
          debut++;
          </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;TD&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;td&quot;</span><span class="cpp1-symbol">)
          {
             debut++;
          }
          decalage--;
       }
       fin=debut;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/TD&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/td&gt;&quot;</span><span class="cpp1-symbol">)
       {
          fin++;
       }
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (decalage&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (decalage&lt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length())
       {
          fin=debut;
          </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/TD&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/td&gt;&quot;</span><span class="cpp1-symbol">)
          {
             fin--;
          }
          fin--;
          decalage++;
       }
       debut=fin;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;TD&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;td&quot;</span><span class="cpp1-symbol">)
       {
          debut--;
       }
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
       </span><span class="cpp1-comment">// decalage = 0
</span><span class="cpp1-space">       fin=debut;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;TD&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">3</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;td&quot;</span><span class="cpp1-symbol">)
       {
             debut--;
       }
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/TD&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">5</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/td&gt;&quot;</span><span class="cpp1-symbol">)
       {
          fin++;
       }
    }
    }
    
    
    texte_retour=texte.Mid(debut,fin - debut);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (suppr_balise)
    {
        debut=texte_retour.First('&lt;');
        </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> loop=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut != -</span><span class="cpp1-number">1</span><span class="cpp1-space"> &amp;&amp; loop &lt; </span><span class="cpp1-number">240</span><span class="cpp1-symbol">) 
        {
            fin=texte_retour.First('&gt;');
            </span><span class="cpp1-comment">//wxMessageBox(texte_retour.Mid(0,debut),&quot;page debut&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            </span><span class="cpp1-comment">//wxMessageBox(texte_retour.Mid(fin+1),&quot;page fin&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            texte_retour=texte_retour.Mid(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,debut) + texte_retour.Mid(fin+</span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
            </span><span class="cpp1-comment">//wxMessageBox(texte_retour,&quot;page tot&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            debut=texte_retour.First('&lt;');
            loop++;
        }
    }
    texte_retour.Trim(</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Trim(</span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">);
    
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;nbsp;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot; &quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;eacute;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&eacute;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;euro;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;Euros&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::chercher_TD() */
</span><span class="cpp1-symbol">}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::chercher_A(wxString texte,wxString texte_a_chercher,wxString&amp; texte_retour,</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> decalage,</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> suppr_balise)
{
    wxString texte_debut;
    wxString texte_fin;
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> debut,fin=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
    
    debut=texte.First(texte_a_chercher);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (debut == -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
    }
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (decalage&gt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (decalage&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length())
       {
          debut++;
          </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;A&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;a&quot;</span><span class="cpp1-symbol">)
          {
             debut++;
          }
          decalage--;
       }
       fin=debut;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/A&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/a&gt;&quot;</span><span class="cpp1-symbol">)
       {
          fin++;
       }
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (decalage&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (decalage&lt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; debut&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length())
       {
          fin=debut;
          </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/A&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/a&gt;&quot;</span><span class="cpp1-symbol">)
          {
             fin--;
          }
          fin--;
          decalage++;
       }
       debut=fin;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;A&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;a&quot;</span><span class="cpp1-symbol">)
       {
          debut--;
       }
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
       </span><span class="cpp1-comment">// decalage = 0
</span><span class="cpp1-space">       fin=debut;
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut&gt;</span><span class="cpp1-number">0</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;A&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(debut,</span><span class="cpp1-number">2</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;a&quot;</span><span class="cpp1-symbol">)
       {
             debut--;
       }
       </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (fin&lt;(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)texte.Length() &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/A&gt;&quot;</span><span class="cpp1-space"> &amp;&amp; texte.Mid(fin,</span><span class="cpp1-number">4</span><span class="cpp1-symbol">)!=</span><span class="cpp1-string">&quot;&lt;/a&gt;&quot;</span><span class="cpp1-symbol">)
       {
          fin++;
       }
    }
    }
    
    texte_retour=texte.Mid(debut,fin - debut);
    </span><span class="cpp1-comment">//wxMessageBox(texte_retour,&quot;ret&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (suppr_balise)
    {
        debut=texte_retour.First('&lt;');
        </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> loop=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (debut != -</span><span class="cpp1-number">1</span><span class="cpp1-space"> &amp;&amp; loop &lt; </span><span class="cpp1-number">240</span><span class="cpp1-symbol">) 
        {
            fin=texte_retour.First('&gt;');
            </span><span class="cpp1-comment">//wxMessageBox(texte_retour.Mid(0,debut),&quot;page debut&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            </span><span class="cpp1-comment">//wxMessageBox(texte_retour.Mid(fin+1),&quot;page fin&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            texte_retour=texte_retour.Mid(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,debut) + texte_retour.Mid(fin+</span><span class="cpp1-number">1</span><span class="cpp1-symbol">);
            </span><span class="cpp1-comment">//wxMessageBox(texte_retour,&quot;page tot&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">            debut=texte_retour.First('&lt;');
            loop++;
        }
    }
    texte_retour.Trim(</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Trim(</span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">);
    
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;nbsp;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot; &quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;eacute;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;&eacute;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    texte_retour.Replace(</span><span class="cpp1-string">&quot;&amp;euro;&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;Euros&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::chercher_TD() */
</span><span class="cpp1-symbol">}

</span><span class="cpp1-comment">// No description
</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> LIVRE_HTML::trancher(wxString&amp; partie_droite,wxString&amp; partie_gauche,wxString centre)
{
	</span><span class="cpp1-comment">/* TODO (#1#): Implement LIVRE_HTML::trancher() */
</span><span class="cpp1-space">	</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> debut;
	debut=partie_gauche.Find(centre);
	</span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (debut&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
	{
       partie_droite=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
       </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
    }
    partie_droite=partie_gauche.Mid(debut+centre.Length());
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (debut!=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    {
       partie_gauche.Remove(debut);
       partie_gauche.Trim(</span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">);
    }
    partie_droite.Trim(</span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">);
    </span><span class="cpp1-comment">//wxMessageBox(partie_gauche,&quot;page gauche&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">//wxMessageBox(partie_droite,&quot;page droite&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-comment">// retourne le premier node dont le nom correspond &agrave; celui pass&eacute; en param&ecirc;tre 
// et si propriete est rensegn&eacute; v&eacute;rifie qu'une propri&eacute;t&eacute; du node &agrave; cette valeur
</span><span class="cpp1-identifier">wxXmlNode * LIVRE_HTML::cherche_node(wxString pos_cherche, wxXmlNode *depart,wxString propriete, wxString pos_courante)
{
    wxString Tempo;
    wxXmlNode *suivant;
    wxXmlNode *recup;
    wxString nouv_pos_courante;
    nouv_pos_courante=pos_courante+</span><span class="cpp1-string">&quot;.&quot;</span><span class="cpp1-symbol">+depart-&gt;GetName();
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (nouv_pos_courante.Lower().EndsWith(pos_cherche.Lower())) {
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (propriete == </span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">) {
            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> depart;
        } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
            wxXmlProperty *prop;
            prop = depart-&gt;GetProperties();
            </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> (prop != NULL) {
                </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (prop-&gt;GetValue().CmpNoCase(propriete) == </span><span class="cpp1-number">0</span><span class="cpp1-symbol">) {
                    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> depart;
                }
                prop=prop-&gt;GetNext();
            }
        }
    }
    suivant=depart-&gt;GetChildren();
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (suivant != NULL) {
        recup=cherche_node(pos_cherche, suivant, propriete, nouv_pos_courante);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (recup != NULL)
            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> recup;
    }
    suivant=depart-&gt;GetNext();
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (suivant != NULL) {
        recup=cherche_node(pos_cherche, suivant, propriete, pos_courante);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (recup != NULL)
            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> recup;
    }
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> NULL;
        
}

</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> LIVRE_HTML::gere_amazon_item(wxXmlNode *item_node,liste_caracteristiques&amp; l_carac) 
{
    caracteristiques* carac;
    wxXmlNode *node_cible;
 
     carac = </span><span class="cpp1-reservedword">new</span><span class="cpp1-space"> caracteristiques();
   
    </span><span class="cpp1-comment">// *** donn&eacute;es indispensable
</span><span class="cpp1-space">    </span><span class="cpp1-comment">// recherche de l'auteur
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Author&quot;</span><span class="cpp1-symbol">,item_node);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        carac-&gt;Auteur=node_cible-&gt;GetNodeContent();
        </span><span class="cpp1-comment">//wxMessageBox(&quot;auteur :&quot;+node_cible-&gt;GetName() + &quot;val: &quot;+node_cible-&gt;GetNodeContent(),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    } </span><span class="cpp1-reservedword">else
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
        </span><span class="cpp1-comment">//wxMessageBox(&quot;POUET : rien&quot;,&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        
     </span><span class="cpp1-comment">// recherche du titre
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Title&quot;</span><span class="cpp1-symbol">,item_node);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        carac-&gt;Titre=node_cible-&gt;GetNodeContent();
        </span><span class="cpp1-comment">//wxMessageBox(&quot;titre :&quot;+node_cible-&gt;GetName() + &quot;val: &quot;+node_cible-&gt;GetNodeContent(),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    } </span><span class="cpp1-reservedword">else
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
     </span><span class="cpp1-comment">// recherche de l'EAN ou ISBN
</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;EAN&quot;</span><span class="cpp1-symbol">,item_node);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        carac-&gt;Isbn=node_cible-&gt;GetNodeContent();
        </span><span class="cpp1-comment">//wxMessageBox(&quot;EAN :&quot;+node_cible-&gt;GetName() + &quot;val: &quot;+node_cible-&gt;GetNodeContent(),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
        node_cible=cherche_node(</span><span class="cpp1-string">&quot;ISBN&quot;</span><span class="cpp1-symbol">,item_node);
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
            carac-&gt;Isbn=node_cible-&gt;GetNodeContent();
            </span><span class="cpp1-comment">//wxMessageBox(&quot;ISBN :&quot;+node_cible-&gt;GetName() + &quot;val: &quot;+node_cible-&gt;GetNodeContent(),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        } </span><span class="cpp1-reservedword">else
</span><span class="cpp1-space">            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
    }
        </span><span class="cpp1-comment">// *** donn&eacute;es facultatives

</span><span class="cpp1-space">    node_cible=cherche_node(</span><span class="cpp1-string">&quot;Label&quot;</span><span class="cpp1-symbol">,item_node);
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (node_cible != NULL) {
        carac-&gt;Editeur=node_cible-&gt;GetNodeContent();
        </span><span class="cpp1-comment">//wxMessageBox(&quot;auteur :&quot;+node_cible-&gt;GetName() + &quot;val: &quot;+node_cible-&gt;GetNodeContent(),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    } 
    
   
    l_carac.Ajouter(carac);
        </span><span class="cpp1-comment">//wxMessageBox(&quot;POUET :&quot;+wxString::Format(&quot;%d&quot;,l_carac.GetCount()),&quot;node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">true</span><span class="cpp1-symbol">;
}

</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> LIVRE_HTML::chercher_texte(wxString texte,liste_caracteristiques&amp; l_livre,</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> type_recherche)
{
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> retour;
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche!=</span><span class="cpp1-number">1</span><span class="cpp1-symbol">) {
    	texte.Replace(</span><span class="cpp1-string">&quot; &quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;%20&quot;</span><span class="cpp1-symbol">);
        </span><span class="cpp1-comment">// recherche via AMAZON
</span><span class="cpp1-space">        wxDateTime now = wxDateTime::Now();
        wxString parametres=</span><span class="cpp1-string">&quot;AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;Keywords=&quot;</span><span class="cpp1-symbol">+texte+</span><span class="cpp1-string">&quot;&amp;Operation=ItemSearch&amp;ResponseGroup=Medium&amp;SearchIndex=Books&amp;Service=AWSECommerceService&amp;Timestamp=&quot;</span><span class="cpp1-symbol">+now.FormatISODate()+</span><span class="cpp1-string">&quot;T&quot;</span><span class="cpp1-symbol">+now.FormatISOTime()+</span><span class="cpp1-string">&quot;.000Z&quot;</span><span class="cpp1-symbol">;
        wxString adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.fr&quot;</span><span class="cpp1-symbol">;

        </span><span class="cpp1-comment">// recherche via AMAZON
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche == </span><span class="cpp1-number">2</span><span class="cpp1-symbol">) {
    	   adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.com&quot;</span><span class="cpp1-symbol">;
        } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (type_recherche == </span><span class="cpp1-number">3</span><span class="cpp1-symbol">) {
    	   adresse=</span><span class="cpp1-string">&quot;ecs.amazonaws.co.uk&quot;</span><span class="cpp1-symbol">;
        }
        
        wxString url=sk::creer_adresse(adresse,parametres);

    	wxString fichier_com=gettempdir() + wxFileName::GetPathSeparators() + wxT(</span><span class="cpp1-string">&quot;amazon.xml&quot;</span><span class="cpp1-symbol">);
    	retour=recupData(url ,fichier_com);
    	wxFFile file;
    	</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> ret=file.Open(fichier_com);
    	</span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (ret==</span><span class="cpp1-reservedword">false</span><span class="cpp1-space"> || retour&lt;</span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
    	{
           wxMessageBox(</span><span class="cpp1-string">&quot;probleme ouverture fichier temporaire&quot;</span><span class="cpp1-symbol">,fichier_com, wxOK | wxICON_EXCLAMATION);
           </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> -</span><span class="cpp1-number">1</span><span class="cpp1-symbol">;
        } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
    	   wxString page_xml;
           file.ReadAll(&amp;page_xml);
            </span><span class="cpp1-comment">//wxMessageBox(page_xml,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        }
        file.Close();
        wxXmlDocument amazon;
        </span><span class="cpp1-comment">//amazon.SetEncoding();
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> test=amazon.Load(fichier_com,wxT(</span><span class="cpp1-string">&quot;ISO-8859-1&quot;</span><span class="cpp1-symbol">));
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (test == </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">) {
            wxMessageBox(</span><span class="cpp1-string">&quot;NOK&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;r&eacute;cup&eacute;ration&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        }
        </span><span class="cpp1-comment">//wxMessageBox(&quot;OK&quot;,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        </span><span class="cpp1-comment">// on r&eacute;cup&egrave;re le node papa (le root quoi)
</span><span class="cpp1-space">        wxXmlNode *papa_root=amazon.GetRoot();
        </span><span class="cpp1-comment">//wxString nom_node=papa_root-&gt;GetName();
</span><span class="cpp1-space">        </span><span class="cpp1-comment">//wxMessageBox(nom_node,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        </span><span class="cpp1-comment">// on r&eacute;cup&egrave;re le premier fils
</span><span class="cpp1-space">        wxXmlNode *petit_node=papa_root-&gt;GetChildren();
        </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> ( petit_node != NULL  ) {
            </span><span class="cpp1-comment">/*if (petit_node != NULL)
                wxMessageBox(petit_node-&gt;GetName(),&quot;nom  node&quot;, wxOK | wxICON_EXCLAMATION);*/
</span><span class="cpp1-space">            petit_node=petit_node-&gt;GetNext();
            </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (petit_node != NULL &amp;&amp; petit_node-&gt;GetName().CmpNoCase(</span><span class="cpp1-string">&quot;Items&quot;</span><span class="cpp1-symbol">) == </span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
                </span><span class="cpp1-reservedword">break</span><span class="cpp1-symbol">;
        }
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (petit_node == NULL) {
            wxMessageBox(</span><span class="cpp1-string">&quot;Probleme lors de la r&eacute;cup&eacute;ration sur Amazon&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-string">&quot;r&eacute;cup&eacute;ration&quot;</span><span class="cpp1-symbol">, wxOK | wxICON_EXCLAMATION);
            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        }
        </span><span class="cpp1-comment">//wxMessageBox(petit_node-&gt;GetName(),&quot;nom du node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> trouve=</span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
        </span><span class="cpp1-comment">// on lit le contenu d'item
</span><span class="cpp1-space">        wxXmlNode *item_node=petit_node-&gt;GetChildren();
        </span><span class="cpp1-comment">//on recherche le premier 'Item'
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">while</span><span class="cpp1-space"> ( item_node != NULL  ) {
            </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (item_node-&gt;GetName().CmpNoCase(</span><span class="cpp1-string">&quot;Item&quot;</span><span class="cpp1-symbol">) == </span><span class="cpp1-number">0</span><span class="cpp1-symbol">) {
                </span><span class="cpp1-comment">// on a trouv&eacute; un item -&gt; on le g&egrave;re
</span><span class="cpp1-space">                trouve++;
                </span><span class="cpp1-comment">//wxMessageBox(item_node-&gt;GetName(),&quot;nom  node&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">                gere_amazon_item(item_node,l_livre);
            }
            item_node=item_node-&gt;GetNext();
        }
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> trouve;
    }
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}
</span><span class="cpp1-comment">// /* Type_recherche d&eacute;fini le moteur utilis&eacute; pour rechercher les livres :
//      0 -&gt; Amazon en utilisant leurs web services
//      1 -&gt; alapage (mais &ccedil;a marche plus alors l'interet de l'utiliser est assez limit&eacute;)
// */ 
// int LIVRE_HTML::chercher_texte_old(wxString texte,liste_caracteristiques&amp; lCaractPopu,liste_caracteristiques&amp; lCaractAutre, int type_recherche)
// {
//     int retour;
// 
//     if (type_recherche!=1) {
//         wxString url=wxT(&quot;http://ecs.amazonaws.com/onca/xml?Service=AWSECommerceService&amp;AWSAccessKeyId=0ND0TZ192YKWMRM086R2&amp;Operation=ItemSearch&amp;SearchIndex=Books&amp;ResponseGroup=Medium&amp;TagPage=2&amp;Keywords=&quot;);
//         
//     	texte.Replace(&quot; &quot;,&quot;%20&quot;);
//     	url=url+texte;
//     	wxString fichier_com=gettempdir() + wxFileName::GetPathSeparators() + wxT(&quot;amazon.xml&quot;);
//     	retour=recupData(url ,fichier_com);
//     	wxFFile file;
//     	bool ret=file.Open(fichier_com);
//     	if (ret==false || retour&lt;0)
//     	{
//            wxMessageBox(&quot;probleme ouverture fichier temporaire&quot;,fichier_com, wxOK | wxICON_EXCLAMATION);
//            return -1;
//         } else {
//     	   wxString page_xml;
//            file.ReadAll(&amp;page_xml);
//             //wxMessageBox(page_xml,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
//         }
//         file.Close();
//         wxXmlDocument amazon;
//         bool test=amazon.Load(fichier_com);
//         if (test == false) {
//             wxMessageBox(&quot;NOK&quot;,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
//             return 0;
//         }
//         wxMessageBox(&quot;OK&quot;,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
//         // on r&eacute;cup&egrave;re le node papa (le root quoi)
//         wxXmlNode *papa_root=amazon.GetRoot();
//         wxString nom_node=papa_root-&gt;GetName();
//         wxMessageBox(nom_node,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
//         // on r&eacute;cup&egrave;re le premier fils
//         wxXmlNode *petit_node=papa_root-&gt;GetChildren();
//         while ( petit_node != NULL  ) {
//             if (petit_node != NULL)
//                 wxMessageBox(petit_node-&gt;GetName(),&quot;nom  node&quot;, wxOK | wxICON_EXCLAMATION);
//             petit_node=petit_node-&gt;GetNext();
//             if (petit_node != NULL &amp;&amp; petit_node-&gt;GetName().CmpNoCase(&quot;Items&quot;) == 0)
//                 break;
//         }
//         if (petit_node == NULL) {
//             wxMessageBox(&quot;Probleme lors de la r&eacute;cup&eacute;ration sur Amazon&quot;,&quot;r&eacute;cup&eacute;ration&quot;, wxOK | wxICON_EXCLAMATION);
//             return 0;
//         }
//         wxMessageBox(petit_node-&gt;GetName(),&quot;nom du node&quot;, wxOK | wxICON_EXCLAMATION);
//         int trouve=0;
//         // on lit le contenu d'item
//         wxXmlNode *item_node=petit_node-&gt;GetChildren();
//         //on recherche le premier 'Item'
//         while ( item_node != NULL  ) {
//             if (item_node-&gt;GetName().CmpNoCase(&quot;Item&quot;) == 0) {
//                 // on a trouv&eacute; un item -&gt; on le g&egrave;re
//                 trouve++;
//                 //wxMessageBox(item_node-&gt;GetName(),&quot;nom  node&quot;, wxOK | wxICON_EXCLAMATION);
//                 gere_amazon_item(item_node,lCaractPopu);
//             }
//             item_node=item_node-&gt;GetNext();
//         }
//         return trouve;
//     } else {
//         // Recherche via ALAPAGE
// 
//     	wxString url_alapage=wxT(&quot;http://www.alapage.com/mx/?type=1&amp;tp=L&amp;fulltext=&quot;);
//     	wxString ISBN;
//     	wxFFile file;
//     	wxString page_html;
//     	wxString sTmp,sTmp2;
//     	bool first;
//     	caracteristiques* cCaract;
//     	int deb;
//     	wxString fichier_com=gettempdir() + wxFileName::GetPathSeparators() + wxT(&quot;com.html&quot;);
//     
//     	size_t nbre=1;
//     
//         nbre=1;
//         while (nbre)
//             nbre = texte.Replace(&quot;  &quot;,&quot; &quot;,true);
//         texte.Replace(&quot; &quot;,&quot;+&quot;,true);
//     	retour=recupData(url_alapage + texte,fichier_com);
//     	
//     	bool ret=file.Open(fichier_com);
//     	if (ret==false || retour&lt;0)
//     	{
//            wxMessageBox(&quot;probleme ouverture fichier temporaire&quot;,fichier_com, wxOK | wxICON_EXCLAMATION);
//            return -1;
//         } else {
//            file.ReadAll(&amp;page_html);
//         }
//         file.Close();
//         
//     	wxString test;
//     	wxString text_a_ecrire;
//     	int i;
//     	
//     	test = interieur(page_html,&quot;&lt;!-- LES PLUS POPULAIRES --&gt;&quot;,&quot;&lt;!-- FIN LES PLUS POPULAIRES --&gt;&quot;);
//     	//wxMessageBox(test,&quot;Interieur texte&quot;, wxOK | wxICON_EXCLAMATION);
//     	i=0;
//     
//     	while (chercher_TD(test,wxT(&quot;mot_editeur=&quot;),text_a_ecrire,0,false)==0)
//     	{
//               //wxMessageBox(text_a_ecrire,&quot;Interieur texte&quot;, wxOK | wxICON_EXCLAMATION);
//     	      //if (chercher_TD(test,wxT(&quot;mot_editeur=&quot;),text_a_ecrire,0,false)!=0)
//               //{
//               //    wxMessageBox(&quot;Impossible de r&eacute;cuperer les caracteristiques&quot;,&quot;Caracteristiques&quot;, wxOK | wxICON_EXCLAMATION);
//               //}
//         
//               text_a_ecrire.Replace(&quot;\n&quot;,&quot; &quot;,true);
//               text_a_ecrire.Replace(&quot;\t&quot;,&quot; &quot;,true);
//               text_a_ecrire.Replace(&quot;\r&quot;,&quot; &quot;,true);
//         
//               nbre=1;
//               while (nbre)
//                     nbre = text_a_ecrire.Replace(&quot;  &quot;,&quot; &quot;,false);
//     	            
//               cCaract = new caracteristiques();
//               
//               chercher_A(text_a_ecrire,wxT(&quot;&lt;/u&gt;&quot;),cCaract-&gt;Titre,0,true);
//               
//               first = true;
//               sTmp2=text_a_ecrire;
//               while (chercher_A(sTmp2,wxT(&quot;mot_auteurs=&quot;),sTmp,0,true)==0)
//               {
//                   if (first)
//                       cCaract-&gt;Auteur=sTmp;
//                   else
//                       cCaract-&gt;Auteur+=&quot;,&quot;+sTmp;
//                   first=false;
//                   deb = sTmp2.First(&quot;mot_auteurs=&quot;);
//                   sTmp2 = sTmp2.Mid(deb+10);
//               }
//               
//               chercher_A(text_a_ecrire,wxT(&quot;mot_editeur=&quot;),cCaract-&gt;Editeur,0,true);
//               
//               chercher_A(text_a_ecrire,wxT(&quot;mot_genre=&quot;),cCaract-&gt;Genre,0,true);
//               
//               test = test.Mid(test.First(&quot;/-/Fiche/Livres/&quot;)+16);
//               ISBN = test.Mid(0,test.First(&quot;/&quot;));
//               cCaract-&gt;Isbn = ISBN;
//               text_a_ecrire += &quot; ISBN=&quot; + ISBN;
//               
//               test = test.Mid(test.First(&quot;mot_editeur=&quot;) + 10);
//               
//               lCaractPopu.Ajouter(cCaract);
//               i++;
//         }
//         
//         test = interieur(page_html,&quot;Les autres r&eacute;ponses&lt;/TD&gt;&quot;,&quot;&lt;!-- RECHERCHE RAPIDE --&gt;&quot;);
//     	
//     	i=0;
//     	while (chercher_TD(test,wxT(&quot;mot_editeur=&quot;),text_a_ecrire,0,false)==0)
//     	{
//               //wxMessageBox(text_a_ecrire,&quot;Interieur texte&quot;, wxOK | wxICON_EXCLAMATION);
//     	      //if (chercher_TD(test,wxT(&quot;mot_editeur=&quot;),text_a_ecrire,0,false)!=0)
//               //{
//               //    wxMessageBox(&quot;Impossible de r&eacute;cuperer les caracteristiques&quot;,&quot;Caracteristiques&quot;, wxOK | wxICON_EXCLAMATION);
//               //}
//         
//               text_a_ecrire.Replace(&quot;\n&quot;,&quot; &quot;,true);
//               text_a_ecrire.Replace(&quot;\t&quot;,&quot; &quot;,true);
//               text_a_ecrire.Replace(&quot;\r&quot;,&quot; &quot;,true);
//         
//               nbre=1;
//               while (nbre)
//                     nbre = text_a_ecrire.Replace(&quot;  &quot;,&quot; &quot;,false);
//     	            
//               cCaract = new caracteristiques();
//               
//               chercher_A(text_a_ecrire,wxT(&quot;&lt;/u&gt;&quot;),cCaract-&gt;Titre,0,true);
//               
//               first = true;
//               sTmp2=text_a_ecrire;
//               while (chercher_A(sTmp2,wxT(&quot;mot_auteurs=&quot;),sTmp,0,true)==0)
//               {
//                   if (first)
//                       cCaract-&gt;Auteur=sTmp;
//                   else
//                       cCaract-&gt;Auteur+=&quot;,&quot;+sTmp;
//                   first=false;
//                   deb = sTmp2.First(&quot;mot_auteurs=&quot;);
//                   sTmp2 = sTmp2.Mid(deb+10);
//               }
//               
//               chercher_A(text_a_ecrire,wxT(&quot;mot_editeur=&quot;),cCaract-&gt;Editeur,0,true);
//               
//               chercher_A(text_a_ecrire,wxT(&quot;mot_genre=&quot;),cCaract-&gt;Genre,0,true);
//               
//               test = test.Mid(test.First(&quot;/-/Fiche/Livres/&quot;)+16);
//               ISBN = test.Mid(0,test.First(&quot;/&quot;));
//               cCaract-&gt;Isbn = ISBN;
//               text_a_ecrire += &quot; ISBN=&quot; + ISBN;
//               
//               test = test.Mid(test.First(&quot;mot_editeur=&quot;) + 10);
//               
//               lCaractAutre.Ajouter(cCaract);
//               i++;
//         }
//         
//     	return 0;
//     }
// }

</span><span class="cpp1-identifier">wxString LIVRE_HTML::interieur(wxString sTexte,wxString sDebut,wxString sFin)
{
    wxString inter=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> iDebut;
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> iFin;
    </span><span class="cpp1-comment">//wxString mess;
</span><span class="cpp1-space">    
    iDebut = sTexte.First(sDebut);
    iFin = sTexte.First(sFin);
    
    </span><span class="cpp1-comment">//mess.Printf(&quot;%d,%d&quot;,iDebut,iFin);
</span><span class="cpp1-space">    </span><span class="cpp1-comment">//wxMessageBox(mess,&quot;mess&quot;, wxOK | wxICON_EXCLAMATION);
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> (iDebut&lt;iFin &amp;&amp; iDebut!=-</span><span class="cpp1-number">1</span><span class="cpp1-space"> &amp;&amp; iFin!=-</span><span class="cpp1-number">1</span><span class="cpp1-symbol">)
    {
        inter = sTexte.Mid(iDebut + sDebut.Length(),iFin - iDebut);
    } </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> {
        inter=</span><span class="cpp1-string">&quot;&quot;</span><span class="cpp1-symbol">;
    }
    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> inter;
}


</span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> LIVRE_HTML::setproxy(</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> utiliser, wxString adresse, wxString port, wxString user, wxString pass) {
    </span><span class="cpp1-reservedword">long</span><span class="cpp1-space"> number;
    prox_utilise=utiliser;
    prox_adresse=adresse;
    port.ToLong(&amp;number);
    prox_port=(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">) number;
    prox_user=user;
    prox_pass=pass;

}
</span></span>
</code></pre>
</body>
</html>