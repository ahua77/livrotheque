// Class automatically generated by Dev-C++ New Class wizard

#include "arboCtrl.h" // class's header file

#include <wx/log.h>

#include "divers.h"
#include "arboCtrlItemData.h"
#include "mabase.h"
#include "biblioFrame.h"
#include "nouv_autre.h"

const int arboCtrl::ID_MNU_RAFRAICHIR = wxNewId();
const int arboCtrl::ID_MNU_PROPRIETES = wxNewId();
const int arboCtrl::ID_MNU_FUSIONNER = wxNewId();

BEGIN_EVENT_TABLE(arboCtrl, wxTreeCtrl)
	EVT_TREE_SEL_CHANGED(-1, arboCtrl::OnSelChanged)
	EVT_TREE_ITEM_COLLAPSED(-1, arboCtrl::OnItemCollapsed)
	EVT_TREE_ITEM_EXPANDED(-1, arboCtrl::OnItemExpanded)
	EVT_TREE_ITEM_MENU(-1, arboCtrl::OnItemMenu)

	EVT_MENU(ID_MNU_RAFRAICHIR, arboCtrl::OnRafraichir)
	EVT_MENU(ID_MNU_PROPRIETES, arboCtrl::OnProprietes)
	EVT_MENU(ID_MNU_FUSIONNER, arboCtrl::OnFusionner)
END_EVENT_TABLE()

wxString arboCtrl::typeArboCtrlStr(E_typeArboCtrl val)
{
    wxString ret = "valeur inconnue";
    switch (val) {
        case E_TAC_auteurParLettre:       ret = "auteur";             break;
        case E_TAC_serieParLettre:        ret = "série";              break;
        case E_TAC_serieParGenre:         ret = "série par genre";    break;
        case E_TAC_artisteParLettre:      ret = "artiste";            break;
        case E_TAC_editeurParLettre:      ret = "éditeur";            break;
        case E_TAC_etatParLettre:         ret = "état";               break;
        case E_TAC_formatParLettre:       ret = "format";             break;
        case E_TAC_genreParLettre:        ret = "genre";              break;
        case E_TAC_langueParLettre:       ret = "langue";             break;
        case E_TAC_localisationParLettre: ret = "localisation";       break;
        case E_TAC_paysParLettre:         ret = "pays";               break;
        case E_TAC_traducteurParLettre:   ret = "traducteur";         break;
        case E_TAC_editeurParGenre:       ret = "éditeur par genre";  break;

        default: 
            ret = wxString::Format("E_TAC inconnu : %d", val);
            break;
    }
    return ret;
}


// class constructor
arboCtrl::arboCtrl(wxWindow* parent, wxWindowID id, biblioFrame* frame, ma_base& baseLivre) 
    : wxTreeCtrl(parent, id, wxDefaultPosition, wxSize(100, 100), wxWANTS_CHARS|wxTR_DEFAULT_STYLE), m_baseLivre(baseLivre)
{
    m_frame = frame;
}

// class destructor
arboCtrl::~arboCtrl()
{
}

void arboCtrl::typeArbo(E_typeArboCtrl val)
{
    m_typeArbo = val;
    
    // annuler tous les noeuds dépliés
    m_mapNoeudsDeplies.clear();
}

// initialise les requêtes pour un type "xxx par lettre"
void arboCtrl::prepareInitTableLettre(wxString table, wxString& query, 
                                      E_typeNoeudArboCtrl& typeNoeudNiv1, E_typeNoeudArboCtrl& typeNoeudNiv2,
                                      wxString& tableNiv1, wxString& tableNiv2 )
{
    query = "SELECT upper(substr(" + table + ".nom, 1,1)), -1, " + table + ".nom nom_" + table + ", " + table + ".rowid id_" + table + ", count(livre.rowid) "
            "FROM livre "
            "LEFT JOIN " + table + " ON " + table + ".rowid = livre.id_" + table + " "
            "WHERE id_" + table + " <> '' "
            "GROUP BY " + table + ".rowid "
            "ORDER BY upper(nom_" + table + ") COLLATE tri_sans_accent";
    typeNoeudNiv1 = E_TNAC_lettre;
    tableNiv1 = table;
    typeNoeudNiv2 = E_TNAC_table;
    tableNiv2 = table;

    wxTreeItemId root = GetRootItem();
    SetItemData(root, new arboCtrlItemData(E_TNAC_racine, table, 0));
}

// initialise les requêtes pour un type "xxx par yyy"
void arboCtrl::prepareInitTableTable(wxString table1, wxString table2, wxString& query, 
                                      E_typeNoeudArboCtrl& typeNoeudNiv1, E_typeNoeudArboCtrl& typeNoeudNiv2,
                                      wxString& tableNiv1, wxString& tableNiv2 )
{
    query = "SELECT " + table2 + ".nom nom_" + table2 + ", " + table2 + ".rowid id_" + table2 + ", "
            + table1 + ".nom nom_" + table1 + ", " + table1 + ".rowid id_" + table1 + ", count(livre.rowid) "
            "FROM " + table1 + " "
            "LEFT JOIN livre ON " + table1 + ".rowid=livre.id_" + table1 + " "
            "LEFT JOIN " + table2 + " ON " + table2 + ".rowid=livre.id_" + table2 + " "
            "WHERE " + table1 + ".nom IS NOT NULL "
            "GROUP BY " + table1 + ".rowid, " + table2 + ".rowid "
            "ORDER BY upper(" + table2 + ".nom) COLLATE tri_sans_accent, upper(" + table1 + ".nom) COLLATE tri_sans_accent";
    typeNoeudNiv1 = E_TNAC_table;
    tableNiv1 = table2;
    typeNoeudNiv2 = E_TNAC_table;
    tableNiv2 = table1;

    wxTreeItemId root = GetRootItem();
    SetItemData(root, new arboCtrlItemData(E_TNAC_racine, table1, 0));
}

int arboCtrl::init()
{
    if (!m_baseLivre.ouverte()) {
        wxLogMessage("arboCtrl::init() --> base fermée : on ignore");
        return 0;
    }
    
    wxLogMessage("arboCtrl::init()");
    Freeze();   // bloque l'affichage pendant la modification / évite de percevoir les effets de vidage / remplissage

    DeleteAllItems();
    wxTreeItemId root = AddRoot("tous");

    wxString query;
    // la requête doit respecter le format suivant :
    //      SELECT libelleNiveau1, codeNiveau1, libelleNiveau2, codeNiveau2, nbLivres
    //        codeNiveau1 = -1 si le regroupement est fait sur la première lettre du libelleNiveau2
    E_typeNoeudArboCtrl typeNoeudNiv1, typeNoeudNiv2;
    wxString tableNiv1, tableNiv2;

    switch(m_typeArbo) {
        case E_TAC_auteurParLettre:
            prepareInitTableLettre("auteur", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_serieParLettre:
            prepareInitTableLettre("serie", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_editeurParLettre:
            prepareInitTableLettre("editeur", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_etatParLettre:
            prepareInitTableLettre("etat", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_artisteParLettre:
            prepareInitTableLettre("artiste", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_formatParLettre:
            prepareInitTableLettre("format", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_genreParLettre:
            prepareInitTableLettre("genre", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_langueParLettre:
            prepareInitTableLettre("langue", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_localisationParLettre:
            prepareInitTableLettre("localisation", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_paysParLettre:
            prepareInitTableLettre("pays", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_traducteurParLettre:
            prepareInitTableLettre("traducteur", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_editeurParGenre:
            prepareInitTableTable("editeur", "genre", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_serieParGenre:
            prepareInitTableTable("serie", "genre", query, typeNoeudNiv1, typeNoeudNiv2, tableNiv1, tableNiv2 );
            break;
        case E_TAC_LASTVALUE:
            m_msgErreur = "typeArbo = E_TAC_LASTVALUE";
            Thaw();
            return -1;
            break;
    }

    wxLogMessage("query = [%s]", query.c_str());


    int ret=m_baseLivre.transac_prepare(query);
    if (ret < 0) {
        Thaw();  // débloque l'affichage du treeCtrl
        m_baseLivre.get_erreur(m_msgErreur);
        wxLogMessage("erreur avec la requête %s : %s", query.c_str(), m_msgErreur.c_str());
        return -1;   // -1 : problème
    }    

    wxTreeItemId noeudSelection = root;
    wxTreeItemId branche = root;
    wxString prevLibelleNiv1;
    while (m_baseLivre.transac_step() == SQLITE_ROW) {
        wxString texte;
        int taille;
        int codeNiv1, codeNiv2, nbLivres;
        wxString libelleNiv1, libelleNiv2;

        m_baseLivre.get_value_char(0, libelleNiv1, taille);
        m_baseLivre.get_value_int(1, codeNiv1);
        m_baseLivre.get_value_char(2, libelleNiv2, taille);
        m_baseLivre.get_value_int(3, codeNiv2);
        m_baseLivre.get_value_int(4, nbLivres);
        
        if (libelleNiv1 == "") {
            libelleNiv1 = "<non renseigné>";
            codeNiv1 = -2;
        }
        
        if (typeNoeudNiv1 == E_TNAC_lettre) {
            // on conserve l'initiale non accentuée pour éviter de se retrouver avec ... - D - E - É - E - F - ... dans l'arbo
            libelleNiv1 = supprimeAccent(libelleNiv1[0]);
        }

        // texte.Printf("%s [%d] - %s [%d] : (%d)", libelleNiv1.c_str(), codeNiv1, libelleNiv2.c_str(), codeNiv2, nbLivres);
        // wxLogMessage("\t%s", texte.c_str());

        // si libelleNiv1 a changé, créer une nouvelle branche de niveau 1
        if (prevLibelleNiv1 != libelleNiv1) {
            if (codeNiv1 == -1)     // niveau 1 est l'initiale du libellé de niveau 2
                codeNiv1 = libelleNiv1[0];
            branche = AppendItem(root, libelleNiv1);
            SetItemData(branche, new arboCtrlItemData(typeNoeudNiv1, tableNiv1, codeNiv1));
            if (cleComplete(branche) == m_cleNoeudSelection)
                noeudSelection = branche;

            prevLibelleNiv1 = libelleNiv1;
        }

        texte.Printf("%s (%d)", libelleNiv2.c_str(), nbLivres);
        // wxLogMessage("\t%s", texte.c_str());
        wxTreeItemId item = AppendItem(branche, texte);
        SetItemData(item, new arboCtrlItemData(typeNoeudNiv2, tableNiv2, codeNiv2));

        if (m_mapNoeudsDeplies.count(cleComplete(branche)) == 1)
            Expand(branche);
        
        if (cleComplete(item) == m_cleNoeudSelection)
            noeudSelection = item;
    }    
    m_baseLivre.transac_fin();

    Expand(root);
    SelectItem(noeudSelection);
    EnsureVisible(noeudSelection);

    Thaw();  // débloque l'affichage du treeCtrl

    wxLogMessage("arboCtrl::init() - sortie");
    return 0;  // 0 : ok
}

void arboCtrl::OnSelChanged(wxTreeEvent& event)
{
    wxLogMessage("arboCtrl::OnSelChanged()");

    wxTreeItemId ancienne_branche = event.GetOldItem();
    wxTreeItemId branche = event.GetItem();

    if (ancienne_branche == branche )
        return;

    // conserver la branche sélectionnée sous la forme clé/clé/clé (pour le cas où le même noeud apparaît dans plusieurs branches
    m_cleNoeudSelection = cleComplete(branche);

    wxArrayString listFrom;
    wxString where = construitRequeteNoeud(branche, listFrom);
    m_frame->remplir_grille(where, listFrom);
}

wxString arboCtrl::construitRequeteNoeud(wxTreeItemId noeud, wxArrayString& listeFrom)
{
    wxString requete;
    do {
        // lecture du type de noeud dans l'itemData attaché
        arboCtrlItemData* itemData = (arboCtrlItemData*)(GetItemData(noeud));
        if (itemData) {
            // wxLogMessage("itemData : %s", itemData->cle().c_str());
            switch(itemData->typeNoeud()) {
                case E_TNAC_lettre:
                    requete += itemData->table() + ".nom LIKE '" + wxString::Format("%c", (char)(itemData->valeurNoeud())) + "%' AND ";
                    listeFrom.Add("id_" + itemData->table());
                    break;
                case E_TNAC_table:
                    if (itemData->valeurNoeud() == -2) 
                        requete += "id_" + itemData->table() +" = '' AND ";
                    else
                        requete += "id_" + itemData->table() +" = " + wxString::Format("%ld", itemData->valeurNoeud()) + " AND ";
                    break;
                case E_TNAC_racine:
                    requete += "NOT id_" + itemData->table() + " = '' AND ";
                    break;
            }
        }
        noeud = GetItemParent(noeud);
    } while (noeud.IsOk());

    // supprimer le dernier " AND ";
    if (requete != "") {
        requete = requete.Left(requete.Len() - 5);
        requete = "WHERE " + requete;
    }

    return requete;
}

wxString arboCtrl::cleComplete(wxTreeItemId noeud)
{
    wxString ret;
    
    do {
        // lecture du type de noeud dans l'itemData attaché
        arboCtrlItemData* itemData = (arboCtrlItemData*)(GetItemData(noeud));
        if (itemData) {
            ret = itemData->cle() + "/" + ret;
        }
        noeud = GetItemParent(noeud);
    } while (noeud.IsOk());
    
    return ret;
}

void arboCtrl::OnItemCollapsed(wxTreeEvent& event)
{
    wxTreeItemId itemId = event.GetItem();
    wxString cle = cleComplete(itemId);
    wxLogMessage("arboCtrl::OnItemCollapsed() : %s", cle.c_str());
    
    m_mapNoeudsDeplies.erase(cle);
    
    wxLogMessage("arboCtrl::OnItemCollapsed() : nb de noeuds dépliés = %d", m_mapNoeudsDeplies.size());
}

void arboCtrl::OnItemExpanded(wxTreeEvent& event)
{
    wxTreeItemId itemId = event.GetItem();
    wxString cle = cleComplete(itemId);
    wxLogMessage("arboCtrl::OnItemExpanded() : %s", cle.c_str());
    
    m_mapNoeudsDeplies[cle] = true;;
    
    wxLogMessage("arboCtrl::OnItemCollapsed() : nb de noeuds dépliés = %d", m_mapNoeudsDeplies.size());
    
}

void arboCtrl::OnItemMenu(wxTreeEvent& event)
{
    wxTreeItemId itemId = event.GetItem();
    if (itemId.IsOk() != true)
        return;

    SelectItem(itemId);
    arboCtrlItemData* itemData = (arboCtrlItemData*)(GetItemData(itemId));

   wxMenu* menu = new wxMenu();

    menu->Append(ID_MNU_RAFRAICHIR, wxT("rafraichir"));
    if (itemData->typeNoeud() == E_TNAC_table) {
        menu->AppendSeparator();
        menu->Append(ID_MNU_PROPRIETES, wxT("propriétés"));
        menu->Append(ID_MNU_FUSIONNER, wxT("fusionner"));
    }

    PopupMenu(menu);

    event.Skip();
    
    delete menu;
        // ne pas faire delete des sous-menu, car cela provoque un plantage de l'appli
        // il semble que le delete menu doit provoquer automatiquement le delete de tous les menus qui lui sont attachés
}

void arboCtrl::OnRafraichir(wxCommandEvent& event)
{
    wxLogMessage("arboCtrl::OnRafraichir()");
    init();
}

void arboCtrl::OnProprietes(wxCommandEvent& event)
{
    wxTreeItemId item = GetSelection();
    
    if (!item.IsOk())
        return;
        
    arboCtrlItemData* itemData = (arboCtrlItemData*)(GetItemData(item));
    if (!itemData)
        return;
        
    if (itemData->typeNoeud() != E_TNAC_table)
        return;

    wxString strId = wxString::Format("%ld", itemData->valeurNoeud());
    wxString nom_table = itemData->table();
    
    nouv_autre* nouv = new nouv_autre(&m_baseLivre, strId, m_frame, -1, nom_table);
    nouv->ShowModal();
}

void arboCtrl::OnFusionner(wxCommandEvent& event)
{
    wxTreeItemId item = GetSelection();
    
    if (!item.IsOk())
        return;
        
    arboCtrlItemData* itemData = (arboCtrlItemData*)(GetItemData(item));
    if (!itemData)
        return;
        
    if (itemData->typeNoeud() != E_TNAC_table)
        return;

    long groupeId = itemData->valeurNoeud();
    wxString nom_table = itemData->table();

    FusionDlg* dlg = new FusionDlg(m_frame, m_baseLivre, nom_table, groupeId);
    dlg->ShowModal();
}
